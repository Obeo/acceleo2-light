<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="WritingQueriesUsingtheLegacyRequestLanguage">Writing Queries Using the Legacy Request Language</h1><p>Before Sirius, the main query language used in Viewpoint was based on Acceleo 2, which is an older, incompatible version of Acceleo and is not maintained anymore. It is still currently deprecated and not maintained, but still supported through an optional extension to ease the transition for existing users who have VSMs using this language. We refer to it as the &#171;legacy language&#187; to avoid confusion with the newer Acceleo (version 3 and above). If you use it your Sirius project must declare a dependency to the <code>org.eclipse.sirius.query.legacy</code> plug-in to ensure the necessary support will be available wherever your modelers are used. You are also encouraged to update your VSMs to use one of the recommended languages supported by Sirius.</p><p>Expressions in this language are enclosed between <code>&lt;%</code> and <code>%&gt;</code> strings. For example, <code>&lt;%name%&gt;</code>. You can mix fixed strings and evaluated parts inside a single expression, for example <code>Some text &lt;%aComputedPart%&gt;. Some other &lt;%computedText%&gt;.</code> See the language&#8217;s <a href="http://www.acceleo.org/doc/obeo/fr/acceleo-2.6-reference.pdf">reference manual</a> for more details.</p><p>In the context of Sirius, you have access to a special feature which can be used to follow &#171;back-links&#187; or &#171;cross-references&#187;. From a given model element, this allows you to easily (and efficiently) find all the elements which refer to it in the scope of the models and representations in the same modeling project. This feature is available through the <code>~</code> operator, which has two forms:</p><ul><li><code>anExpression.~</code>: if <code>anExpression</code> evaluates to the model element <em>M</em>, then the expression will return the set of all model elements which have a direct reference to <em>M</em>.</li><li><code>anExpression.~ref</code>, where <code>ref</code> can be any valid name: if <code>anExpression</code> evaluates to the model element <em>M</em>, then the expression will return the set of all model elements which have a direct reference to <em>M</em> through a reference named <code>ref</code>.</li></ul><p>For example if model element <em>A</em> has a reference named <em>r1</em> to model element <em>C</em>, and <em>B</em> has a reference <em>r2</em> to <em>C</em>, then <code>C.~r1</code> will return <em>A</em> but not <em>B</em>, while <code>C.~</code> would return both <em>A</em> and <em>B</em>.</p><p><em>Warning:</em> To test a Java service invoked through a legacy language expression, you have to launch an Eclipse runtime or to type its parameters with <code>EObject</code> and then cast them to your domain types in the service body.The legacy language interpreter is not able to retrieve non-deployed service with domain types parameters.</p></body></html>