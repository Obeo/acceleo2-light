<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
		<title>Writing_Queries_Using_Legacy_Acceleo</title>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.sirius.doc/doc/resources/html_bootstrap/css/bootstrap.css"/>
		<link type="text/css" rel="stylesheet" href="/help/topic/org.eclipse.sirius.doc/doc/resources/style_customization.css"/>
	</head>
	<body>
		<h1 id="WritingQueriesUsingtheLegacyRequestLanguage">Writing Queries Using the Legacy Request Language</h1>
		<p>Before Obeo Designer 7.0, the main query language used in Sirius was based on Acceleo 2, which is an older, incompatible version of Acceleo and is not maintained anymore. It is still supported and not currently deprecated. We refer to it as the &#171;legacy language&#187; to avoid confusion with the newer Acceleo (version 3 and above). If you use it your Sirius project must declare a dependency to the 
			<code>org.eclipse.sirius.query.legacy</code> plug-in to ensure Acceleo 2 support will be available wherever your modelers are used.
		</p>
		<p>Expressions in this language are enclosed between 
			<code>&lt;%</code> and 
			<code>%&gt;</code> strings. For example, 
			<code>&lt;%name%&gt;</code>. You can mix fixed strings and evaluated parts inside a single expression, for example 
			<code>Some text &lt;%aComputedPart%&gt;. Some other &lt;%computedText%&gt;.</code> See the language&#8217;s 
			<a href="/help/topic/fr.obeo.dsl.designer.doc/acceleo2/html/Acceleo%202.6%20-%20Reference.html">reference manual</a> for more details.
		</p>
		<p>In the context of Sirius, you have access to a special feature which can be used to follow &#171;back-links&#187; or &#171;cross-references&#187;. From a given model element, this allows you to easily (and efficiently) find all the elements which refer to it in the scope of the models and representations in the same modeling project. This feature is available through the 
			<code>~</code> operator, which has two forms:
		</p>
		<ul>
			<li>
				<code>anExpression.~</code>: if 
				<code>anExpression</code> evaluates to the model element 
				<em>M</em>, then the expression will return the set of all model elements which have a direct reference to 
				<em>M</em>.
			</li>
			<li>
				<code>anExpression.~ref</code>, where 
				<code>ref</code> can be any valid name: if 
				<code>anExpression</code> evaluates to the model element 
				<em>M</em>, then the expression will return the set of all model elements which have a direct reference to 
				<em>M</em> through a reference named 
				<code>ref</code>.
			</li>
		</ul>
		<p>For example if model element 
			<em>A</em> has a reference named 
			<em>r1</em> to model element 
			<em>C</em>, and 
			<em>B</em> has a reference 
			<em>r2</em> to 
			<em>C</em>, then 
			<code>C.~r1</code> will return 
			<em>A</em> but not 
			<em>B</em>, while 
			<code>C.~</code> would return both 
			<em>A</em> and 
			<em>B</em>.
		</p>
		<p>
			<em>Warning:</em> To test a Java service invoked through a legacy language expression, you have to launch an Eclipse runtime or to type its parameters with 
			<code>EObject</code> and then cast them to your domain types in the service body.The legacy language interpreter is not able to retrieve non-deployed service with domain types parameters.
		</p>
	</body>
</html>